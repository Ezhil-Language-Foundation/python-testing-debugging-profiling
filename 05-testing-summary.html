<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Testing</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Testing</h1></a>
          <h2 class="subtitle">Summary</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="learning-objectives"><span class="glyphicon glyphicon-certificate"></span>Learning Objectives</h2>
</div>
<div class="panel-body">
<ul>
<li>Understand the place of testing in a scientific workflow.</li>
<li>Understand that testing has many forms.</li>
</ul>
</div>
</section>
<p>In this lesson, we have covered defensive programming and testing with unit tests. Here is a little summary:</p>
<p>The first step toward getting the right answers from our programs is to assume that mistakes <em>will</em> happen and to guard against them. This is called <strong>defensive programming</strong> and the most common way to do it is to add alarms and tests into our code so that it checks itself.</p>
<p><strong>Testing</strong> should be a seamless part of scientific software development process. This is analogous to experiment design in the experimental science world:</p>
<ul>
<li>At the beginning of a new project, tests can be used to help guide the overall architecture of the project.</li>
<li>The act of writing tests can help clarify how the software should be perform when you are done.</li>
<li>In fact, starting to write the tests <em>before</em> you even write the software might be advisable. (Such a practice is called <em>test-driven development</em>)</li>
</ul>
<p><em>Exceptions and Assertions</em>: While writing code, <code>exceptions</code> and <code>assertions</code> can be added to sound an alarm as runtime problems come up. These kinds of tests, are embedded in the software iteself and handle, as their name implies, exceptional cases rather than the norm.</p>
<p><em>Unit Tests</em>: Unit tests investigate the behavior of units of code (such as functions, classes, or data structures). By validating each software unit across the valid range of its input and output parameters, tracking down unexpected behavior that may appear when the units are combined is made vastly simpler.</p>
<p>Unit tests are not the only kind of test we can write. While unit tests are the core of every test suite, there are at least two other kinds of tests:</p>
<p><em>Regression Tests</em>: Regression tests defend against new bugs, or regressions, which might appear due to new software and updates. A typical situation where you need such tests is if you write simulation software: you can save the result of a simulation run and then write a test that compares the result of your simulation against the stored result. If at any time your results start to differ from the stored results, this is a very important warning sign (note that it could also mean that the previous result was wrong!).</p>
<p><em>Integration Tests</em>: Integration tests check that various pieces of the software work together as expected. In contrast to unit tests, they do not test a single isolated piece of code but rather how those units work together.</p>
<p>The structure of integration tests is very similar to that of unit tests. There is an expected result, which is compared against the observed value. However, what goes in to creating the expected result or setting up the code to run can be considerably more complicated and more involved. Integration tests can also take much longer to run because of how much more work they do. This is a useful classification to keep in mind while writing tests. It helps separate out which test should be easy to write (unit) and which ones may require more careful consideration (integration).</p>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/paris-swc/python-testing-debugging-profiling">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  </body>
</html>
